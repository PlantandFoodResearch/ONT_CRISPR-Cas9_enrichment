---
title: "CRISPR cas9 coverage"
author: "Marcus Davy"
date: "12/13/2019"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(BiocParallel)
library(NGS)
library(RLinuxModules)
library(Rsamtools)
library(ShortRead)
library(lattice)
library(rtracklayer)
library(testthat)

module("purge")
module("load samtools/1.9")

rm(list=ls())


#` module("load samtools/1.9")

#` Setting PORECHOP=TRUE reduces Guppy Fastq records by 4, guppy pass by 1
#` and creates width differences between summary and fastq files.
DEBUG    <- TRUE
PORECHOP <- TRUE
n        <- 1000

WORKERS  <- 7

use_corrected_canu <- FALSE
plot_kripr_oligos  <- TRUE

if(use_corrected_canu) {
  #` New corrected canu bam files
  guppy_bam    <- "/workspace/hrpelg/Red_Flesh_ON/Guppy_basecalling/04.canu/minimap/correct_reads_to_GD/Guppy_canu_corrected_vs_GDv1.1.bam"
  albacore_bam <- "/workspace/hrpelg/Red_Flesh_ON/04.canu/minimap/correct_reads_to_GD/canu_corrected_vs_GDv1.1.bam"
} else {
  #` Original bam files
  guppy_bam    <- "/workspace/hrpelg/Red_Flesh_ON/Guppy_basecalling/03.minimap2/Guppy_RedFlesh.bam"
  albacore_bam <- "/workspace/hrpelg/Red_Flesh_ON/03.minimap2/Redflesh.bam"
}

bedfile <- "MYB10.bed"
ref_gd  <- "/input/genomic/plant/Malus/Genome/GDDH_v1.1/Decompress/GDDH13_1-1_formatted.fasta"

Sys.setenv(GUPPY_BAM    = guppy_bam,
           ALBACORE_BAM = albacore_bam,
           BEDFILE      = bedfile,
           REFERENCE    = ref_gd)

source("functions.R")
```


## 0. Quality control

The [pycoQC](https://github.com/a-slide/pycoQC) was used for quality control and filtering.

```bash
#` albacore pycoQC call
bsub -o $WKDIR/01.pycoQC/log/QC1.out -e $WKDIR/01.pycoQC/log/QC1.err -J ONT_QC1 \"pycoQC -f $WKDIR/albacore2/Red_flesh_ON_run1_Cas9/all_summary_run1.txt -o $WKDIR/01.pycoQC/pycoQC_summary_run1

#` Guppy pycoQC call
bsub -o $WKDIR/01.pycoQC/log/QC1.out -e $WKDIR/01.pycoQC/log/QC1.err -J ONT_QC1 \"pycoQC -f $WKDIR/sequencing_summary.txt $WKDIR/01.pycoQC/pycoQC_summary_run1
```

## Sanity check files generation times

```{r engine="bash"}
./check_dates.sh
```

## 1. Load bed coordinate Metadata

MYB10 coordinates;

```{r myb10_coords}
myb10_coords <- import(Sys.getenv("BEDFILE"), format="bed")
print(myb10_coords)
```


## 2. Load Base call summaries

Summary statistics from `albacore2`, and `guppy` base callers. The summary
files have changed slightly between the two base callers, they do not have
identical column fields;

```{r}
albacore_summary <- read.table("/workspace/hrpelg/Red_Flesh_ON/albacore2/Red_flesh_ON_run1_Cas9/all_summary_run1.txt", header=TRUE, as.is = TRUE)
# albacore_summary <- read.table("/workspace/hramwd/github/analysis-workflows/Malus/Red_Flesh_ON/albacore2/Red_flesh_ON_run1_Cas9/all_summary_run1.txt", header=TRUE, as.is = TRUE)
guppy_summary <- read.table("/workspace/hrpelg/Red_Flesh_ON/Guppy_basecalling/sequencing_summary.txt", header=TRUE, as.is = FALSE)

dim(albacore_summary)
dim(guppy_summary)

table(albacore_summary$passes_filtering)
table(guppy_summary$passes_filtering)

#`
#` Create filtered summaries
#`
albacore_summary_pass <- albacore_summary[albacore_summary$passes_filtering%in%"True", ]
albacore_summary_fail <- albacore_summary[albacore_summary$passes_filtering%in%"True", ]
guppy_summary_pass    <- guppy_summary[guppy_summary$passes_filtering%in%TRUE, ]
guppy_summary_fail    <- guppy_summary[guppy_summary$passes_filtering%in%FALSE, ]
```


### Differences in summary fields

There are a few subtle changes in the reported summary statistics fields;

```{r, echo=FALSE}
cat("[ Field names: intersection ]\n")
intersect(names(albacore_summary), names(guppy_summary))

cat("[ Field names: Unique to albacore ]\n")
setdiff(names(albacore_summary), names(guppy_summary))

cat("[ Field names: Unique to guppy ]\n")
setdiff(names(guppy_summary), names(albacore_summary))
```


### Sanity checking two separate albacore runs

Base calling using albacore were independently run against the same `fast5`
files, checking the statistics summary files generated illustrates that the
records returned may be in a different row position probably due to
differences in results return order from parallelisation;

```{r}
basecall_stats_versions()
```


## 3. Load Fastq files

The Fastq files generated by each base caller should be the same length;


```{r fq_width_to_df}
#` Albacore fastq reads
if(PORECHOP) {
  #` Porechop adapter trimmed fastq files
  albacore.fq <- readFastq("/workspace/hrpelg/Red_Flesh_ON/02.poreChop/All_DS_RedFlesh_ON_run1_cas_after_porechop_dis.fastq.gz")
  guppy.fq    <- readFastq("/workspace/hrpelg/Red_Flesh_ON/Guppy_basecalling/02.poreChop/After_PoreCHOP_RedFlesh_ON_GUPPY_cas.fastq.gz")
} else {
  #` Raw fastq files
  albacore.fq <- readFastq("/workspace/hrpelg/Red_Flesh_ON/albacore2/All_DS_RedFlesh_ON_run1_cas.fastq")
  guppy.fq    <- readFastq("/workspace/hrpelg/Red_Flesh_ON/Guppy_basecalling/02.poreChop/Merged_RedFlesh_ON_GUPPY_cas.fastq.gz")
}

length(albacore.fq)
length(guppy.fq)
```

however the `albacore` base caller returns the filtered reads, while the
`guppy` base caller returns `r length(guppy.fq)` unfiltered reads.


### Sanity check duplicate sequences in fastq files

We appear to have 24 duplicate sequences in the `albacore.fq` file;

```{r echo=FALSE}
#` Find duplicates
albacore_dups <- ont_duplicates(albacore.fq)
guppy_dups    <- ont_duplicates(guppy.fq)

#` Tabulate duplicates
cat("[ albacore duplicate table ]\n")
table(table(albacore_dups$all_ids))

cat("[ albacore duplicate ids ]\n")
print(albacore_dups$dup_ids)

cat("[ Sorted albacore sequences ]\n")
print(srsort(sread(albacore.fq[albacore_dups$all_ids%in%albacore_dups$dup_ids])))

#` Tabulate duplicates
cat("[ guppy duplicate table ]\n")
table(table(guppy_dups$all_ids))
```


Fix the albacore.fq data set by removing the duplicates;

```{r}
#` Subset unique albacore sequences
albacore_unique.fq <- albacore.fq[!albacore_dups$dup_ind]

length(albacore_unique.fq)
```


### Sanity check Fastq files to statistics

The `albacore` base caller filters the sequences, so the number of sequences should match the number of passed sequences in the table.

```{r check_albacore}
expect_equal(
  sort(split_ids(ShortRead::id(albacore_unique.fq))),
  sort(albacore_summary$read_id[albacore_summary$passes_filtering%in%"True"])
)
```


The unfiltered `guppy` fastq file should have the same number of sequences as records in the statistics summary,
however there appears to be 4 additional records in the summary not present in the `guppy` fastq file;

```{r echo=FALSE}
cat("[ Unfiltered guppy fastq sequences ]\n")
length(guppy.fq)

cat("[ guppy statistics records ]\n")
nrow(guppy_summary)
```

What are the 4 additional guppy records?

```{r find_guppy_missing}
cat("[ missing ids ]\n")
setdiff(guppy_summary$read_id, split_ids(ShortRead::id(guppy.fq)))

missing_ind <- which(!guppy_summary$read_id%in%split_ids(ShortRead::id(guppy.fq)))


cat("[ widths of missing sequences: sequence_length_template field ]\n")
guppy_summary[missing_ind, "sequence_length_template"]

knitr::kable(guppy_summary[missing_ind,])
```


## 4. Load bam coverage

Using Rsamtools to extract coverage information from the bam files, note: no flag filtering is currently used to remove poor quality reads. 

```{r extract_cov1}
bamfile1 <- Sys.getenv("GUPPY_BAM")
bamfile2 <- Sys.getenv("ALBACORE_BAM")
guppy_all    <- bamCoverage(1, myb10_coords, bamfile1)
albacore_all <- bamCoverage(1, myb10_coords, bamfile2)
guppy_fwd    <- bamCoverage(1, myb10_coords, bamfile1, orient="fwd")
albacore_fwd <- bamCoverage(1, myb10_coords, bamfile2, orient="fwd")
guppy_rev    <- bamCoverage(1, myb10_coords, bamfile1, orient="revcomp")
albacore_rev <- bamCoverage(1, myb10_coords, bamfile2, orient="revcomp")
```



Note: The field `passes_filtering` logical has changed to upper case for
`guppy`, probably for downstream analysis using R.


## 5. Publication: Table 3

Try to replicate the figures in table 3;

```{r}
table3 <- data.frame(
  Method           = c("Albacore2","Guppy"), 
  All_reads        = c(nrow(albacore_summary), nrow(guppy_summary)),
  Pass_reads       = c(nrow(albacore_summary_pass), nrow(guppy_summary_pass)),
  bases_all        = c(sum(albacore_summary$sequence_length_template), sum(guppy_summary$sequence_length_template)),
  bases_pass       = c(sum(albacore_summary_pass$sequence_length_template), sum(guppy_summary_pass$sequence_length_template)),
  median_all       = c(median(albacore_summary$sequence_length_template), median(guppy_summary$sequence_length_template)),
  median_pass      = c(median(albacore_summary_pass$sequence_length_template), median(guppy_summary_pass$sequence_length_template)),
  N50_all          = c(N50(albacore_summary$sequence_length_template), N50(guppy_summary$sequence_length_template)),
  N50_pass         = c(N50(albacore_summary_pass$sequence_length_template), N50(guppy_summary_pass$sequence_length_template)),
  median_qual_all  = c(round(median(albacore_summary$mean_qscore_template), 2), round(median(guppy_summary$mean_qscore_template), 2)),
  median_qual_pass = c(round(median(albacore_summary_pass$mean_qscore_template), 2), round(median(guppy_summary_pass$mean_qscore_template), 2))
)

knitr::kable(table3)
```


### Table 3 amended

There is one read ID which is present and a pass in the guppy summary file, however it is missing from the guppy fastq file.

```{r}
setdiff(guppy_summary_pass$read_id, split_ids(ShortRead::id(guppy.fq)))
```

This record should be removed for an amended version of Table 3;

```{r}
missing_id <- setdiff(guppy_summary_pass$read_id, split_ids(ShortRead::id(guppy.fq)))

guppy_summary_pass    <- guppy_summary[guppy_summary$passes_filtering%in%TRUE  & (!guppy_summary$read_id%in%missing_id), ]
guppy_summary_fail    <- guppy_summary[guppy_summary$passes_filtering%in%FALSE & (!guppy_summary$read_id%in%missing_id), ]

table3_amended <- data.frame(
  Method           = c("Albacore2","Guppy"),
  All_reads        = c(nrow(albacore_summary), nrow(guppy_summary)),
  Pass_reads       = c(nrow(albacore_summary_pass), nrow(guppy_summary_pass)),
  bases_all        = c(sum(albacore_summary$sequence_length_template), sum(guppy_summary$sequence_length_template)),
  bases_pass       = c(sum(albacore_summary_pass$sequence_length_template), sum(guppy_summary_pass$sequence_length_template)),
  median_all       = c(median(albacore_summary$sequence_length_template), median(guppy_summary$sequence_length_template)),
  median_pass      = c(median(albacore_summary_pass$sequence_length_template), median(guppy_summary_pass$sequence_length_template)),
  N50_all          = c(N50(albacore_summary$sequence_length_template), N50(guppy_summary$sequence_length_template)),
  N50_pass         = c(N50(albacore_summary_pass$sequence_length_template), N50(guppy_summary_pass$sequence_length_template)),
  median_qual_all  = c(round(median(albacore_summary$mean_qscore_template), 2), round(median(guppy_summary$mean_qscore_template), 2)),
  median_qual_pass = c(round(median(albacore_summary_pass$mean_qscore_template), 2), round(median(guppy_summary_pass$mean_qscore_template), 2))
)

knitr::kable(table3_amended)
```


### Sanity check summary statistics

```{r}
#`
#` Comparing sequence length to `sequence_length_template` field
#` ind <- 1 fails for albacore...
ind <- 2
expect_equal(width(sread(albacore_unique.fq[grepl( albacore_summary$read_id[ind], id(albacore_unique.fq))])), albacore_summary[ind, "sequence_length_template"])
expect_equal(width(sread(guppy.fq[grepl( guppy_summary$read_id[ind], id(guppy.fq))])), guppy_summary[ind, "sequence_length_template"])


## Quality
albacore_summary[ind, ]
summary(as(quality(albacore_unique.fq[grepl( albacore_summary$read_id[ind], id(albacore_unique.fq))]), "numeric"))

guppy_summary[ind, ]
summary(as(quality(guppy.fq[grepl( guppy_summary$read_id[ind], id(guppy.fq))]), "numeric"))
```


## 6. Generate data sets for figures

```{r}
#`
#` Sanity check read IDs to subset
#`
setdiff(guppy_summary$read_id, split_ids(ShortRead::id(guppy.fq)))
#` The missing long read is not in the Fastq file
setdiff(guppy_summary_pass$read_id, split_ids(ShortRead::id(guppy.fq)))

table(guppy_summary_pass$read_id %in% split_ids(ShortRead::id(guppy.fq)))

length(intersect(split_ids(ShortRead::id(guppy.fq)), guppy_summary_pass$read_id))


#`
#` Filter guppy.fq for passed reads only
#`
guppy_subset_ind <- split_ids(ShortRead::id(guppy.fq))%in%guppy_summary_pass$read_id
guppy_pass.fq <- guppy.fq[guppy_subset_ind]

if(PORECHOP) {
  expect_equal(length(guppy_pass.fq), 6377)
} else {
  expect_equal(length(guppy_pass.fq), 6378)
}

dset <- rbind(
  data.frame(Method="Albacore2", width=width(albacore_unique.fq)),
  data.frame(Method="Guppy", width=width(guppy_pass.fq))
)

#`
#` Summaries in same order as Fastq files
#`
ind <- match(split_ids(ShortRead::id(albacore_unique.fq)), albacore_summary$read_id)
albacore_summary_pass_sort <- albacore_summary[ind,]

ind <- match(split_ids(ShortRead::id(guppy_pass.fq)), guppy_summary$read_id)
guppy_summary_pass_sort <- guppy_summary[ind,]

## Sanity check
expect_equal(as.character(albacore_summary_pass_sort$read_id), split_ids(ShortRead::id(albacore_unique.fq)))
expect_equal(as.character(guppy_summary_pass_sort$read_id), split_ids(ShortRead::id(guppy_pass.fq)))


if(!grepl("aklppr31", Sys.getenv("HOSTNAME"))) {
  tmpl <- system.file(package="batchtools", "templates", "openlava-simple.tmpl")
  bparam <- MulticoreParam(workers=WORKERS) ## , template=tmpl)
  register(bparam)
}


#`
#` Extract quality scores
#`
metric <- mean

if(DEBUG) {
  system.time(guppy_qual <- unlist(bplapply(1:n, filter_quality, quality(guppy_pass.fq), fun=metric, BPPARAM = bpparam("MulticoreParam"))))
  system.time(albacore_qual <- unlist(bplapply(1:n, filter_quality, quality(albacore_unique.fq), fun=metric, BPPARAM = bpparam("MulticoreParam"))))
  #` Sanity check
  #` system.time(median_quality(,  quality(guppy.fq)[1:n]))
} else {
  system.time(guppy_qual <- unlist(bplapply(seq(guppy_pass.fq), filter_quality, quality(guppy_pass.fq), fun=metric, BPPARAM = bpparam("MulticoreParam"))))
  system.time(albacore_qual <- unlist(bplapply(seq(albacore_unique.fq), filter_quality, quality(albacore_unique.fq), fun=metric, BPPARAM = bpparam("MulticoreParam"))))
}
```

## Sanity checking widths

We have base calling summaries which have a `sequence_length_template` field, and filtered Fastq which have
sequence widths, we neeed to check they are equal;

```{r}
#` Albacore
albacore_width <- data.frame(read_id   = albacore_summary_pass_sort$read_id, 
                             width_sum = albacore_summary_pass_sort$sequence_length_template, 
                             width_fq = width(albacore_unique.fq)) # porechoped adapters

albacore_width_issues <- albacore_width[albacore_width$width_sum!=albacore_width$width_fq,]
head(albacore_width_issues)
dim(albacore_width_issues)

#` One read longer than 
table(albacore_width$width_sum>=albacore_width$width_fq)

plot(albacore_summary_pass_sort$sequence_length_template, width(albacore_unique.fq), pch=16, cex=0.3, log="xy")

#` Guppy
guppy_width <- data.frame(read_id   = guppy_summary_pass_sort$read_id, 
                             width_sum = guppy_summary_pass_sort$sequence_length_template, 
                             width_fq = width(guppy_pass.fq)) # porechoped adapters

guppy_width_issues <- guppy_width[guppy_width$width_sum!=guppy_width$width_fq,]
head(guppy_width_issues)
dim(guppy_width_issues)

table(guppy_width$width_sum>=guppy_width$width_fq)

plot(guppy_summary_pass_sort$sequence_length_template, width(guppy_pass.fq), pch=16, cex=0.3, log="xy")
```

There are discrepancies.


## Visualizing width vs quality

```{r}
albacore_summary_qual <- albacore_summary_pass_sort$mean_qscore_template
guppy_summary_qual    <- guppy_summary_pass_sort$mean_qscore_template



if(DEBUG) {
dcols <- densCols(guppy_qual, width(guppy.fq)[1:n])
plot(guppy_qual, width(guppy.fq)[1:n], pch=16, cex=0.4, col=dcols,
     main = "Guppy", xlab="Quality", ylab="Read Length")

dcols <- densCols(albacore_qual, width(albacore.fq)[1:n])
plot(albacore_qual, width(albacore.fq)[1:n], pch=16, cex=0.4, col=dcols,
     main = "Albacore2", xlab="Quality", ylab="Read Length")
} else {
  dcols <- densCols(guppy_qual, width(guppy.fq))
plot(guppy_qual, width(guppy.fq), pch=16, cex=0.4, col=dcols,
     main = "Guppy", xlab="Quality", ylab="Read Length")

dcols <- densCols(albacore_qual, width(albacore.fq))
plot(albacore_qual, width(albacore.fq), pch=16, cex=0.4, col=dcols,
     main = "Albacore2", xlab="Quality", ylab="Read Length")
}
```


### Visualizing sequence widths

```{r fig2}
#`
#` https://github.com/Actinidia/GBS/blob/98b36d3bc5fcb2cdc41b506dc17ffd21261397f0/RandomTagvsStandard/paper/figureGeneration.Rmd
#`
nBins   <- seq(0, log10(max(dset$width)), length=70+1)
xAxis <- 0:7
plotObj1 <- histogram( ~ log10(width) |  Method, data=dset, col="white", breaks=nBins,
          aspect=1, layout=c(2,1), xlab=expression(log[10]("Read Length")),
          type="count",
          scales = list(x = list(alternating=FALSE, at=xAxis, rot=90, labels=(10^xAxis))),
          between=list(x=0.3, y=0.3), panel=function(x,y, ...){
            panel.histogram(x, ...)
            panel.abline(v=N50(x), lty=3, col="red")
            panel.text(x=N50(x), y=470, "N50", cex=0.75)
          })
print(plotObj1)
```


## Visualizing contig length metric

```{r Nf_plot}
f <- seq(0,1, length=201)

dset_Nf <- rbind(
  data.frame(Method="Albacore2", f = f, Nf = sapply(f, function(x)Nf(albacore_summary_pass_sort$sequence_length_template, x))),
  data.frame(Method="Guppy",     f = f, Nf = sapply(f, function(x)Nf(guppy_summary_pass_sort$sequence_length_template, x)))
#` data.frame(Method="Guppy - Albacore", f=f,
#`            Nf = sapply(f, function(x)Nf(width(guppy.fq), x)) - sapply(f, function(x)Nf(width(albacore.fq), x)))
)

#` contig length needed to cover 50% of the genome
xAxis <- seq(0, 120000, length=4)
plotObj3 <- xyplot(f ~ Nf | Method, data=dset_Nf, layout=c(2,1), between=list(x=0.3, y=0.3),
       xlab=expression(paste(N[f],  ", contig length to cover fraction (f) of the genome")),
        scales = list(x = list(alternating=FALSE, at=xAxis, rot=0)),
                       ylab="fraction (f)",
                       panel=function(x,y, ...) {
                         panel.lines(x,y, ...)
                         ind <- which(y==0.5)
                         panel.text(x[ind], y[ind], label=bquote(N[50] == .(x[ind])))
                       })
print(plotObj3)
```


## Generating Base quality data set

The total number of quality scores based on raw fastq data;

```{r quality_check}
sum(width(quality(albacore.fq)))
sum(width(quality(guppy.fq)))
```

These are too many quality scores to visualize in R, and the files are reflective of all derived reads, not the ones in the region of interest only.


Extracting Base quality scores in region of interest;

```{r quality_region_to_df}

#` Albacore fastq reads
albacore_region.fq <- readFastq("fastq_region/All_DS_RedFlesh_ON_run1_cas_after_porechop_dis.fastq.gz")
guppy_region.fq    <- readFastq("fastq_region/After_PoreCHOP_RedFlesh_ON_GUPPY_cas.fastq.gz")

# dset<- rbind(
#    data.frame(Method="Albacore2", quality=as(quality(albacore_region.fq), "numeric")),
#    data.frame(Method="Guppy", quality=as(quality(guppy_region.fq), "numeric"))
# )

#`
#` Summaries in same order as Fastq files
#`
ind <- match(split_ids(ShortRead::id(albacore_region.fq)), albacore_summary$read_id)
albacore_summary_region_sort <- albacore_summary[ind,]

ind <- match(split_ids(ShortRead::id(guppy_region.fq)), guppy_summary$read_id)
guppy_summary_region_sort <- guppy_summary[ind,]

## Sanity check
expect_equal(as.character(albacore_summary_region_sort$read_id), split_ids(ShortRead::id(albacore_region.fq)))
expect_equal(as.character(guppy_summary_region_sort$read_id), split_ids(ShortRead::id(guppy_region.fq)))


dset<- rbind(
   data.frame(Method="Albacore2", quality=albacore_summary_region_sort$mean_qscore_template),
   data.frame(Method="Guppy", quality=guppy_summary_region_sort$mean_qscore_template)
)


dim(dset)

#` Summary statistics (Text above Table 3)
with(dset, tapply(quality, Method, function(x)round(summary(x),2)))
```


### Visualizing sequence quality

```{r fig3}
#`
#` https://github.com/Actinidia/GBS/blob/98b36d3bc5fcb2cdc41b506dc17ffd21261397f0/RandomTagvsStandard/paper/figureGeneration.Rmd
#`
nBins   <- seq(0, max(dset$quality), length=90+1)
xAxis <- 0:7

#` Histogram
plotObj4 <- histogram( ~ quality |  Method, data=dset, col="white", breaks=nBins,
          aspect=1, layout=c(2,1), xlab=expression("Quality Score"),
          type="count", main=which_coords(myb10_coords),
          scales = list(x = list(alternating=FALSE)), #, at=xAxis, rot=90, labels=(xAxis))),
          between=list(x=0.3, y=0.3), panel=function(x,y, ...){
            panel.histogram(x, ...)
          })
print(plotObj4)

#` Violin plot - see example(panel.violin)
#`set.seed(42)
#`dset_sub <- dset[sample(nrow(dset), 1000000),]
plotObj5 <- bwplot( quality ~  Method, data=dset, xlab="Base Caller", ylim=c(-0.5, 16),
          aspect=1, ylab=expression("Base Call Quality Scores"),
          type="count", main=which_coords(myb10_coords),
          scales = list(x = list(alternating=FALSE)),
          between=list(x=0.3, y=0.3),
       panel = function(..., box.ratio) {
           panel.violin(..., width=2, col = "transparent",
                        varwidth = FALSE, box.ratio = box.ratio)
           panel.bwplot(..., fill = NULL, box.ratio = .1)
       } )
print(plotObj5)
```


## Generating coverage data set

```{r cov_to_df}
dat1 <- data.frame(
  pos       = seq(length(guppy_all$cov)) + guppy_all$start - 1,
  coverage  = as.integer(guppy_all$cov),
  type      = "Guppy",
  orient    = "all"
)
dat2 <- data.frame(
  pos       = seq(length(albacore_all$cov)) + albacore_all$start - 1,
  coverage  = as.integer(albacore_all$cov),
  type      = "Albacore2",
  orient    = "all"
)
dat3 <- data.frame(
  pos       = seq(length(guppy_fwd$cov)) + guppy_fwd$start - 1,
  coverage  = as.integer(guppy_fwd$cov),
  type      = "Guppy",
  orient    = "forward"
)
dat4 <- data.frame(
  pos       = seq(length(albacore_fwd$cov)) + albacore_fwd$start - 1,
  coverage  = as.integer(albacore_fwd$cov),
  type      = "Albacore2",
  orient    = "forward"
)
dat5 <- data.frame(
  pos       = seq(length(guppy_rev$cov)) + guppy_rev$start - 1,
  coverage  = as.integer(guppy_rev$cov),
  type      = "Guppy",
  orient    = "reverse complement"
)
dat6 <- data.frame(
  pos       = seq(length(albacore_rev$cov)) + albacore_rev$start - 1,
  coverage  = as.integer(albacore_rev$cov),
  type      = "Albacore2",
  orient    = "reverse complement"
)

#` Forward difference
cov1 <- guppy_fwd
cov2 <- albacore_fwd
if(length(cov2$cov) == length(cov1$cov)) {
  delta_start <- cov2$start
}
if(length(cov2$cov) < length(cov1$cov)) {
  toPad <- rep(0, abs(length(cov2$cov) - length(cov1$cov)))
  cov2$cov <- append(cov2$cov, toPad)
  delta_start <- cov2$start
}
if(length(cov1$cov) < length(cov2$cov)) {
  toPad <- rep(0, abs(length(cov2$cov) - length(cov1$cov)))
 cov1$cov <- append(cov1$cov, toPad)
 delta_start <- cov1$start
}
delta <-  cov1$cov - cov2$cov
dat7 <- data.frame(
  pos       = seq(length(delta)) + delta_start - 1,
  coverage  = as.integer(delta),
  type      = "Guppy-Albacore2",
  orient    = "forward"
)

#` Reverse complement difference
cov1 <- guppy_rev
cov2 <- albacore_rev
if(length(cov2$cov) == length(cov1$cov)) {
  delta_start <- cov2$start
}
if(length(cov2$cov) < length(cov1$cov)) {
  toPad <- rep(0, abs(length(cov2$cov) - length(cov1$cov)))
  cov2$cov <- append(cov2$cov, toPad)
  delta_start <- cov2$start
}
if(length(cov1$cov) < length(cov2$cov)) {
  toPad <- rep(0, abs(length(cov2$cov) - length(cov1$cov)))
 cov1$cov <- append(cov1$cov, toPad)
 delta_start <- cov1$start
}
delta <-  cov1$cov - cov2$cov
dat8 <- data.frame(
  pos       = seq(length(delta)) + delta_start - 1,
  coverage  = as.integer(delta),
  type      = "Guppy-Albacore2",
  orient    = "reverse complement"
)
dat <- rbind(dat3, dat4, dat5, dat6, dat7, dat8)
```


KRISPR RNA oligo matches to Genome;

```{r crRNA_matches}
#`crRNA genome coordinates;
patterns <- krispr_rna_oligos()
ref      <- readDNAStringSet(Sys.getenv("REFERENCE"))

#` Sort wrt chromosome names
ref <- ref[sort(names(ref))]

#` Sequence matching
mindex1 <- vmatchPattern(patterns[[1]], ref)$Chr09
mindex2 <- vmatchPattern(patterns[[2]], ref)$Chr09
mindex3 <- vmatchPattern(reverseComplement(patterns[[3]]), ref)$Chr09
mindex4 <- vmatchPattern(patterns[[4]], ref)$Chr09
```


### Visualizing GC content

```{r ref_GC}
flank        <- 10000
myb10_region <- myb10_coords + flank

ref_region <- narrow(ref["Chr09"], start(myb10_region), end(myb10_region))

window <- 500
#`compute the GC content in a sliding window (as a fraction) for a sequence no. 364
gc <-  rowSums(letterFrequencyInSlidingView(ref_region[[1]], window, c("G", "C")))/window
plot(gc, type = 'l', main=paste(which_coords(myb10_coords), " (red lines)"))


window_start <- start(myb10_coords) - start(myb10_region) - window
window_end   <- window_start + width(myb10_coords)
abline(v=window_start, col="red", lty=3)
abline(v=window_end, col="red", lty=3)
```


### Visualizing coverage

Coverage including difference;

```{r fig4, echo=FALSE}

if(use_corrected_canu) {
  xmin <- min(dat$pos) - 6355
  xmax <- max(dat$pos) + 37
} else {
  xmin <- min(dat$pos) ## 35536363
  xmax <- max(dat$pos) ## 35556652
}

plotObj6 <- xyplot(coverage ~ pos | type, data=dat,
                   xlab="Physical position on Chr09", ylab="Coverage", aspect=1,
                   groups=orient, between=list(x=0.3, y=0.3), layout=c(3, 1),
                   main=which_coords(myb10_coords), xlim = c(xmin, xmax),
                   key = simpleKey(text = c("Forward", "Reverse"),
                                   columns = 2, space = "top", lines=TRUE, points=FALSE),
                   scales=list(alternating=FALSE), panel=function(x,y, ...) {
                     panel.abline(v = start(myb10_coords), col = "darkgrey", lty = 1, cex=0.2)
                     panel.abline(v = end(myb10_coords),   col = "darkgrey", lty = 1, cex=0.2)

                     if(plot_kripr_oligos) {
                       panel.abline(v = start(mindex1), col = "red",   lty = 8, cex = 0.2)
                     # panel.abline(v = start(mindex2), col = "green", lty = 8, cex = 0.9)
                       panel.abline(v = start(mindex3), col = "green", lty = 8, cex = 0.2)
                     # panel.abline(v = start(mindex4), col = "red",   lty = 8, cex = 0.9)
                     }

                     panel.superpose(x,y, type="l", ...)
                   })

print(plotObj6)
```


Coverage excluding difference;

```{r fig4B, echo=FALSE}

if(use_corrected_canu) {
  xmin <- min(dat$pos) - 6355
  xmax <- max(dat$pos) + 37
} else {
  xmin <- min(dat$pos) ## 35536363
  xmax <- max(dat$pos) ## 35556652
}

plotObj7 <- xyplot(coverage ~ pos | type, data=dat, subset = (dat$type!="Guppy-Albacore2"),
                   xlab="Physical position on Chr09", ylab="Coverage", aspect=1,
                   groups=orient, between=list(x=0.3, y=0.3), layout=c(2, 1),
                   main=which_coords(myb10_coords), xlim = c(xmin, xmax),
                   key = simpleKey(text = c("Forward", "Reverse"),
                                   columns = 2, space = "top", lines=TRUE, points=FALSE),
                   scales=list(alternating=FALSE), panel=function(x,y, ...) {
                     panel.abline(v = start(myb10_coords), col = "darkgrey", lty = 1, cex=0.2)
                     panel.abline(v = end(myb10_coords),   col = "darkgrey", lty = 1, cex=0.2)

                     if(plot_kripr_oligos) {
                       panel.abline(v = start(mindex1), col = "red",   lty = 8, cex = 0.2)
                     # panel.abline(v = start(mindex2), col = "green", lty = 8, cex = 0.9)
                       panel.abline(v = start(mindex3), col = "green", lty = 8, cex = 0.2)
                     # panel.abline(v = start(mindex4), col = "red",   lty = 8, cex = 0.9)
                     }

                     panel.superpose(x,y, type="l", ...)
                   })

print(plotObj7)
```

Examining coverage difference;

```{r fig4C, echo=FALSE}

if(use_corrected_canu) {
  xmin <- min(dat$pos) - 6355
  xmax <- max(dat$pos) + 37
} else {
  xmin <- min(dat$pos) ## 35536363
  xmax <- max(dat$pos) ## 35556652
}

plotObj8 <- xyplot(coverage ~ pos | type, data=dat, subset = (dat$type=="Guppy-Albacore2"),
                   xlab="Physical position on Chr09", ylab="Coverage", aspect=1,
                   groups=orient, between=list(x=0.3, y=0.3), layout=c(1, 1),
                   main=which_coords(myb10_coords), xlim = c(xmin, xmax),
                   key = simpleKey(text = c("Forward", "Reverse"),
                                   columns = 2, space = "top", lines=TRUE, points=FALSE),
                   scales=list(alternating=FALSE), panel=function(x,y, ...) {
                     panel.abline(v = start(myb10_coords), col = "darkgrey", lty = 1, cex=0.2)
                     panel.abline(v = end(myb10_coords),   col = "darkgrey", lty = 1, cex=0.2)

                     if(plot_kripr_oligos) {
                       #panel.abline(v = start(mindex1), col = "red",   lty = 8, cex = 0.2)
                       panel.abline(v = start(mindex2), col = "black", lty = 8, cex = 0.9)
                       #panel.abline(v = start(mindex3), col = "green", lty = 8, cex = 0.2)
                       #panel.abline(v = start(mindex4), col = "red",   lty = 8, cex = 0.9)
                     }

                     panel.superpose(x,y, type="l", ...)
                   })

print(plotObj8)
```

Examining coverage difference start region;

```{r fig4D, echo=FALSE}

if(use_corrected_canu) {
  xmin <- min(dat$pos) - 6355
  xmax <- max(dat$pos) + 37
} else {
  xmin <- min(dat$pos) ## 35536363
  xmax <- max(dat$pos) ## 35556652
}

plotObj9 <- xyplot(coverage ~ pos | type, data=dat, subset = (dat$type=="Guppy-Albacore2"),
                   xlab="Physical position on Chr09", ylab="Coverage", aspect=1,
                   groups=orient, between=list(x=0.3, y=0.3), layout=c(1, 1),
                   main=paste(which_coords(myb10_coords), "start region"), xlim=c(35542500, 35543000),
                   key = simpleKey(text = c("Forward", "Reverse"),
                                   columns = 2, space = "top", lines=TRUE, points=FALSE),
                   scales=list(alternating=FALSE), panel=function(x,y, ...) {
                     panel.abline(v = start(myb10_coords), col = "darkgrey", lty = 1, cex=0.2)
                     panel.abline(v = end(myb10_coords),   col = "darkgrey", lty = 1, cex=0.2)

                     if(plot_kripr_oligos) {
                       panel.abline(v = start(mindex1), col = "red",   lty = 8, cex = 0.2)
                       panel.abline(v = start(mindex2)+20, col = "red", lty = 8, cex = 0.9)
                       #panel.abline(v = start(mindex3), col = "green", lty = 8, cex = 0.2)
                       #panel.abline(v = start(mindex4), col = "red",   lty = 8, cex = 0.9)
                     }

                     panel.superpose(x,y, type="l", ...)
                   })

print(plotObj9)
```

Examining coverage difference start region (magnified);

```{r fig4E, echo=FALSE}

if(use_corrected_canu) {
  xmin <- min(dat$pos) - 6355
  xmax <- max(dat$pos) + 37
} else {
  xmin <- min(dat$pos) ## 35536363
  xmax <- max(dat$pos) ## 35556652
}

plotObj10 <- xyplot(coverage ~ pos | type, data=dat, subset = (dat$type=="Guppy-Albacore2"),
                   xlab="Physical position on Chr09", ylab="Coverage", aspect=1,
                   groups=orient, between=list(x=0.3, y=0.3), layout=c(1, 1),
                   main=paste(which_coords(myb10_coords), "start region"), xlim=c(start(mindex2), start(mindex2)+40),
                   key = simpleKey(text = c("Forward", "Reverse"),
                                   columns = 2, space = "top", lines=TRUE, points=FALSE),
                   scales=list(alternating=FALSE), panel=function(x,y, ...) {
                     panel.abline(v = start(myb10_coords), col = "darkgrey", lty = 1, cex=0.2)
                     panel.abline(v = end(myb10_coords),   col = "darkgrey", lty = 1, cex=0.2)

                     if(plot_kripr_oligos) {
                       panel.abline(v = start(mindex1), col = "red",   lty = 8, cex = 0.2)
                       panel.abline(v = start(mindex2)+20, col = "red", lty = 8, cex = 0.9)
                       panel.abline(v = start(mindex2)+35, col = "grey", lty = 8, cex = 0.9)
                       #panel.abline(v = start(mindex3), col = "green", lty = 8, cex = 0.2)
                       #panel.abline(v = start(mindex4), col = "red",   lty = 8, cex = 0.9)
                     }

                     panel.superpose(x,y, type="l", ...)
                   })

print(plotObj10)
```


Visualizing Albacore start spike region `samtools tview`;

```{r tview_albacore1, engine="bash"}
samtools view -F 16 -u $ALBACORE_BAM Chr09:35542848-35542888 | samtools sort -o albacore_region_fwd.bam
samtools index albacore_region_fwd.bam
samtools view -f 16 -u $ALBACORE_BAM Chr09:35542848-35542888 | samtools sort -o albacore_region_rc.bam
samtools index albacore_region_rc.bam

echo "[ Albacore tview forward reads ]"
samtools tview -d T -p Chr09:35542848-35542888 albacore_region_fwd.bam $REFERENCE
echo "[ Albacore tview reverse complement reads ]"
samtools tview -d T -p Chr09:35542848-35542888 albacore_region_rc.bam $REFERENCE
```

Visualizing Guppy start spike region `samtools tview`;

```{r tview_guppy1, engine="bash"}
samtools view -F 16 -u $GUPPY_BAM Chr09:35542848-35542888 | samtools sort -o albacore_region_fwd.bam
samtools index albacore_region_fwd.bam
samtools view -f 16 -u $GUPPY_BAM Chr09:35542848-35542888 | samtools sort -o albacore_region_rc.bam
samtools index albacore_region_rc.bam

echo "[ Guppy tview forward reads ]"
samtools tview -d T -p Chr09:35542848-35542888 albacore_region_fwd.bam $REFERENCE
echo "[ Guppy tview reverse complement reads ]"
samtools tview -d T -p Chr09:35542848-35542888 albacore_region_rc.bam $REFERENCE
```

Examining coverage difference end region;

```{r fig4F, echo=FALSE}

if(use_corrected_canu) {
  xmin <- min(dat$pos) - 6355
  xmax <- max(dat$pos) + 37
} else {
  xmin <- min(dat$pos) ## 35536363
  xmax <- max(dat$pos) ## 35556652
}

plotObj2 <- xyplot(coverage ~ pos | type, data=dat, subset = (dat$type=="Guppy-Albacore2"),
                   xlab="Physical position on Chr09", ylab="Coverage", aspect=1,
                   groups=orient, between=list(x=0.3, y=0.3), layout=c(1, 1),
                   main=paste(which_coords(myb10_coords), "end region"), xlim = c(35550000, 35552000),
                   key = simpleKey(text = c("Forward", "Reverse"),
                                   columns = 2, space = "top", lines=TRUE, points=FALSE),
                   scales=list(alternating=FALSE), panel=function(x,y, ...) {
                     panel.abline(v = start(myb10_coords), col = "darkgrey", lty = 1, cex=0.2)
                     panel.abline(v = end(myb10_coords),   col = "darkgrey", lty = 1, cex=0.2)

                     if(plot_kripr_oligos) {
                       #panel.abline(v = start(mindex1), col = "red",   lty = 8, cex = 0.2)
                       #panel.abline(v = start(mindex2), col = "red", lty = 8, cex = 0.9)
                       panel.abline(v = start(mindex3)-100, col = "grey", lty = 8, cex = 0.2)
                       panel.abline(v = start(mindex3), col = "green", lty = 8, cex = 0.2)
                       panel.abline(v = start(mindex4), col = "red",   lty = 8, cex = 0.9)
                     }

                     panel.superpose(x,y, type="l", ...)
                   })

print(plotObj2)
```

### Coverage statistics


```{r}
start_region <- start(mindex2)+45
end_region   <- start(mindex3)-100

dat_region <- dat[start_region <= dat$pos & dat$pos <= end_region, ]

plotObj11 <- xyplot(coverage ~ pos | type, data=dat_region, subset = (dat_region$type=="Guppy-Albacore2"),
                   xlab="Physical position on Chr09", ylab="Coverage", aspect=1,
                   groups=orient, between=list(x=0.3, y=0.3), layout=c(1, 1),
                   main=paste(which_coords(myb10_coords), "end region"), xlim = c(start_region-200, end_region+200),
                   key = simpleKey(text = c("Forward", "Reverse"),
                                   columns = 2, space = "top", lines=TRUE, points=FALSE),
                   scales=list(alternating=FALSE), panel=function(x,y, ...) {
                     panel.abline(v = start(myb10_coords), col = "darkgrey", lty = 1, cex=0.2)
                     panel.abline(v = end(myb10_coords),   col = "darkgrey", lty = 1, cex=0.2)

                     if(plot_kripr_oligos) {

                       panel.abline(v = start(mindex2)+45, col = "green", lty = 8, cex = 0.9)
                       panel.abline(v = start(mindex3)-100, col = "red", lty = 8, cex = 0.2)

                     }

                     panel.superpose(x,y, type="l", ...)
                   })

print(plotObj11)

#` Summary statistics (forward/revcomp regions)
cat(paste0("[ Region ", "Chr09:", start_region,"-", end_region), "]\n")
with(dat_region, tapply(coverage, list(type, orient), function(x)round(mean(x),2)))
with(dat_region, tapply(coverage, list(type, orient), function(x)round(sd(x),2)))
```

In the coordinate range Chr09:35542893-35550589 which is 98% of the
7,841 bp red flesh MYB10 gene locus region of interest, the difference
in forward read coverage between base callers is relatively uniform
where the coverage depth of the Guppy base caller is on average 7.9X
higher than the Albacore2 base caller with standard deviation 0.87X.

### Coverage vs off target

Comparing on target coverage to off target coverage;

```{r}
#` myb10 coverage
myb10_mean_cov <- with(dat_region, tapply(coverage, list(type), function(x)round(mean(x),2)))

#` myb10 region
myb10_width <- width(myb10_coords)

nsamples <- 1000

set.seed(42)
for( chr in names(ref)[10]) {
  start_samples <- sort(sample((width(ref[1]) - 2*myb10_width), nsamples))
  which_sample  <- GRanges(seqnames = names(ref[chr]), ranges = IRanges(start=start_samples, width=myb10_width))

  cov_sample <- bplapply(seq(nsamples), bamCoverage, which_sample, bamfile1, BPPARAM = bpparam("MulticoreParam"))
  cvg_means   <- sapply(cov_sample, function(x)ifelse(!is.null(x$cov), mean(x$cov), NA))

  print(summary(cvg_means))

  hist(cvg_means,
             main=paste0(chr, ": Off target vs on myb10 site"),
             xlab="Average coverage",
             xlim=c(0, round(max(myb10_mean_cov), -2)))
  points(x=myb10_mean_cov[["Guppy"]], y=1, col="green", pch=16, cex=0.5)
  points(x=myb10_mean_cov[["Albacore2"]], y=1, col="red", pch=16, cex=0.5)
  legend(x=70, y=125, legend=c("Guppy","Albacore2"), col=c("green","red"), pch=16, cex=0.8)
}
```

## See also

* [Publication draft](https://myiplant.plantandfood.co.nz/personal/hrpelg/_layouts/15/WopiFrame2.aspx?sourcedoc=/personal/hrpelg/Documents/DS_Draft_manuscript_Elena_Lopez-Girona/Main_Draft_manuscript_DS_Elena-Lopez-Girona_29-04-2020%20(3).docx&action=default)


```{r scratchpad, echo=FALSE, include=FALSE}
ind <- which(split_ids(ShortRead::id(guppy.fq))%in%"5914b119-4dec-43f7-9379-91a8641c5004")
guppy_summary$read_id%in%"5914b119-4dec-43f7-9379-91a8641c5004"

sread(guppy.fq[ind])
guppy_summary[guppy_summary$read_id%in%"5914b119-4dec-43f7-9379-91a8641c5004", ]

#`
#` Venn Diagram tests
#`
require(VennDiagram)

venn.plot <- venn.diagram(
	list(guppy_summary = guppy_summary$read_id, guppy_pass_stats = guppy_summary_pass$read_id),
	"guppy_summary.tiff"
	)

venn.plot <- venn.diagram(
	list(guppy_fastq = split_ids(ShortRead::id(guppy.fq)), guppy_pass_stats = guppy_summary_pass$read_id),
	"guppy_passes.tiff"
	)

venn.plot <- venn.diagram(
	list(guppy_fastq = split_ids(ShortRead::id(guppy.fq)), guppy_stats = guppy_summary$read_id),
	"guppy.tiff"
	)

#`
#` Testing bam aligned coordinates
#`

#` x <- read.table(pipe("samtools depth /workspace/hrpelg/Red_Flesh_ON/Guppy_basecalling/04.canu/minimap/correct_reads_to_GD/Guppy_canu_corrected_vs_GDv1.1.bam"))
#` names(x) <- c("seqname","coord","depth")

#`
#` Width Violin plot - see example(panel.violin)
#`
# plotObj2 <- bwplot( log10(width) ~  Method, data=dset, xlab="Base Caller",
#           aspect=1, ylab=expression(log[10]("Read Length")),
#           type="count", main=which_coords(myb10_coords),
#           scales =  list(y = list(alternating=FALSE), at=xAxis, rot=0, labels=(10^xAxis)),
#           between=list(x=0.3, y=0.3),
#        panel = function(..., box.ratio) {
#            panel.violin(..., width=1, col = "transparent",
#                         varwidth = FALSE, box.ratio = box.ratio)
#            panel.bwplot(..., fill = NULL, box.ratio = .1)
#        } )
# print(plotObj2)

```
